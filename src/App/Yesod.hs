{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE ViewPatterns #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}

module App.Yesod
  ( main,
    -- Suppress warning for unused top-level bindings generated by TH
    resourcesApp,
    Widget,
  )
where

import App.Cart
  ( BookingId (unBookingId),
    CartId (CartId, unCartId),
    PaymentId (unPaymentId),
    processBooking,
    processPayment,
  )
import App.Config (Config (configPaymentMaxRetries), configInit)
import App.Text (tshow)
import Blammo.Logging
  ( HasLogger (loggerL),
    Logger,
    Message ((:#)),
    MonadLogger (monadLoggerLog),
    logInfo,
    logWarn,
    runLoggerLoggingT,
    (.=),
  )
import Blammo.Logging.Simple (newLoggerEnv)
import Control.Concurrent (threadDelay)
import Control.Monad (when)
import Control.Monad.IO.Class (MonadIO (liftIO))
import Data.Text (Text)
import Lens.Micro (lens)
import Network.HTTP.Types (Status, status409)
import Network.Wai.Handler.Warp (run)
import UnliftIO.Async (concurrently)
import Yesod.Core
  ( MonadHandler,
    PathPiece,
    Yesod (messageLoggerSource),
    getsYesod,
    mkYesod,
    parseRoutes,
    renderRoute,
    sendResponseStatus,
    toWaiAppPlain,
  )

data App = App
  { appConfig :: Config,
    appLogger :: Logger
  }

instance HasLogger App where
  loggerL = lens appLogger $ \x y -> x {appLogger = y}

appInit :: IO App
appInit = do
  config <- configInit
  logger <- newLoggerEnv
  let app =
        App
          { appConfig = config,
            appLogger = logger
          }
  pure app

mkYesod
  "App"
  [parseRoutes|
  /cart/#CartId/purchase CartPurchaseR POST
|]

deriving instance PathPiece CartId

instance Yesod App where
  messageLoggerSource app _logger loc source level msg =
    runLoggerLoggingT app $ monadLoggerLog loc source level msg

sendStatusText :: (MonadHandler m) => Status -> Text -> m a
sendStatusText = sendResponseStatus

postCartPurchaseR :: CartId -> Handler Text
postCartPurchaseR cartId = do
  when (cartId == CartId "def456") $ do
    logWarn $ "Cart already purchased" :# ["cart_id" .= cartId]
    sendStatusText status409 "Cart already purchased"
  logInfo $ "Cart purchase starting" :# ["cart_id" .= cartId]
  paymentMaxRetries <- getsYesod (configPaymentMaxRetries . appConfig)
  (bookingId, paymentId) <-
    concurrently (processBooking cartId) (processPayment cartId)
  liftIO $ threadDelay (100 * 1000)
  let response =
        mconcat
          [ "cartId: ",
            unCartId cartId,
            "\n",
            "paymentMaxRetries: ",
            tshow paymentMaxRetries,
            "\n",
            "bookingId: ",
            unBookingId bookingId,
            "\n",
            "paymentId: ",
            unPaymentId paymentId,
            "\n"
          ]
  logInfo $ "Cart purchase successful" :# ["cart_id" .= cartId]
  pure response

main :: IO ()
main = do
  app <- appInit
  waiApp <- toWaiAppPlain app
  let port = 3000
  run port waiApp
