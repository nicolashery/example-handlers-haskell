{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE ViewPatterns #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}

module App.Yesod
  ( main,
    -- Suppress warning for unused top-level bindings generated by TH
    resourcesApp,
    Widget,
  )
where

import App.Cart
  ( BookingId (unBookingId),
    CartException (CartException),
    CartId (CartId, unCartId),
    HasCartConfig (getBookingUrl, getPaymentUrl),
    PaymentId (unPaymentId),
    processBooking,
    processPayment,
  )
import App.Config
  ( Config (configBookingUrl, configPaymentMaxRetries, configPaymentUrl),
    configInit,
  )
import App.Text (tshow)
import Blammo.Logging
  ( HasLogger (loggerL),
    Logger,
    Message ((:#)),
    MonadLogger (monadLoggerLog),
    logInfo,
    logWarn,
    runLoggerLoggingT,
    (.=),
  )
import Blammo.Logging.Simple (newLoggerEnv)
import Control.Concurrent (threadDelay)
import Control.Monad (when)
import Control.Monad.IO.Class (MonadIO (liftIO))
import Data.Text (Text)
import Lens.Micro (lens)
import Network.HTTP.Types (Status, status409, status500)
import Network.Wai.Handler.Warp (run)
import UnliftIO.Async (concurrently)
import UnliftIO.Exception (catch)
import Yesod.Core
  ( MonadHandler,
    PathPiece,
    Yesod (messageLoggerSource),
    getsYesod,
    mkYesod,
    parseRoutes,
    renderRoute,
    sendResponseStatus,
    toWaiAppPlain,
  )
import Yesod.Core.Types (HandlerData (handlerEnv), RunHandlerEnv (rheSite))

data App = App
  { appConfig :: Config,
    appLogger :: Logger
  }

instance HasLogger App where
  loggerL = lens appLogger $ \x y -> x {appLogger = y}

instance HasCartConfig App where
  getBookingUrl = configBookingUrl . appConfig
  getPaymentUrl = configPaymentUrl . appConfig

instance HasCartConfig (HandlerData App App) where
  getBookingUrl = getBookingUrl . rheSite . handlerEnv
  getPaymentUrl = getPaymentUrl . rheSite . handlerEnv

appInit :: IO App
appInit = do
  config <- configInit
  logger <- newLoggerEnv
  let app =
        App
          { appConfig = config,
            appLogger = logger
          }
  pure app

mkYesod
  "App"
  [parseRoutes|
  /cart/#CartId/purchase CartPurchaseR POST
|]

deriving instance PathPiece CartId

instance Yesod App where
  messageLoggerSource app _logger loc source level msg =
    runLoggerLoggingT app $ monadLoggerLog loc source level msg

sendStatusText :: (MonadHandler m) => Status -> Text -> m a
sendStatusText = sendResponseStatus

postCartPurchaseR :: CartId -> Handler Text
postCartPurchaseR cartId = do
  when (cartId == CartId "def456") $ do
    logWarn $ "Cart already purchased" :# ["cart_id" .= cartId]
    sendStatusText status409 "Cart already purchased"
  logInfo $ "Cart purchase starting" :# ["cart_id" .= cartId]
  paymentMaxRetries <- getsYesod (configPaymentMaxRetries . appConfig)
  let action :: Handler (Either Text (BookingId, PaymentId))
      action = Right <$> concurrently (processBooking cartId) (processPayment cartId)
      handler :: CartException -> Handler (Either Text (BookingId, PaymentId))
      handler (CartException msg) = pure $ Left msg
  result <- catch action handler
  case result of
    Left msg -> do
      logWarn $ ("Cart purchase failed: " <> msg) :# ["cart_id" .= cartId]
      sendStatusText status500 ("Cart purchase failed: " <> msg)
    Right (bookingId, paymentId) -> do
      liftIO $ threadDelay (100 * 1000)
      let response =
            mconcat
              [ "cartId: ",
                unCartId cartId,
                "\n",
                "paymentMaxRetries: ",
                tshow paymentMaxRetries,
                "\n",
                "bookingId: ",
                unBookingId bookingId,
                "\n",
                "paymentId: ",
                unPaymentId paymentId,
                "\n"
              ]
      logInfo $ "Cart purchase successful" :# ["cart_id" .= cartId]
      pure response

main :: IO ()
main = do
  app <- appInit
  waiApp <- toWaiAppPlain app
  let port = 3000
  run port waiApp
