{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE ViewPatterns #-}

module App.Yesod
  ( main,
    -- Suppress warning for unused top-level bindings generated by TH
    resourcesApp,
    Widget,
  )
where

import App.Cart
  ( BookingId (unBookingId),
    PaymentId (unPaymentId),
    newBookingPayload,
    newPaymentPayload,
    processBooking,
    processPayment,
  )
import App.Config (Config (configPaymentMaxRetries), configInit)
import App.Text (tshow)
import Blammo.Logging
  ( HasLogger (loggerL),
    Logger,
    Message ((:#)),
    MonadLogger (monadLoggerLog),
    logInfo,
    runLoggerLoggingT,
    (.=),
  )
import Blammo.Logging.Simple (newLoggerEnv)
import Control.Concurrent (threadDelay)
import Control.Monad.IO.Class (MonadIO (liftIO))
import Data.Text (Text)
import Lens.Micro (lens)
import Network.Wai.Handler.Warp (run)
import UnliftIO.Async (concurrently)
import Yesod.Core
  ( Yesod (messageLoggerSource),
    getsYesod,
    mkYesod,
    parseRoutes,
    renderRoute,
    toWaiAppPlain,
  )

data App = App
  { appConfig :: Config,
    appLogger :: Logger
  }

instance HasLogger App where
  loggerL = lens appLogger $ \x y -> x {appLogger = y}

appInit :: IO App
appInit = do
  config <- configInit
  logger <- newLoggerEnv
  let app =
        App
          { appConfig = config,
            appLogger = logger
          }
  pure app

mkYesod
  "App"
  [parseRoutes|
  /cart/#Text/purchase CartPurchaseR POST
|]

instance Yesod App where
  messageLoggerSource app _logger loc source level msg =
    runLoggerLoggingT app $ monadLoggerLog loc source level msg

postCartPurchaseR :: Text -> Handler Text
postCartPurchaseR cartId = do
  logInfo $ "Cart purchase starting" :# ["cart_id" .= cartId]
  paymentMaxRetries <- getsYesod (configPaymentMaxRetries . appConfig)
  (bookingId, paymentId) <-
    concurrently (processBooking newBookingPayload) (processPayment newPaymentPayload)
  liftIO $ threadDelay (100 * 1000)
  let response =
        mconcat
          [ "cartId: ",
            cartId,
            "\n",
            "paymentMaxRetries: ",
            tshow paymentMaxRetries,
            "\n",
            "bookingId: ",
            unBookingId bookingId,
            "\n",
            "paymentId: ",
            unPaymentId paymentId,
            "\n"
          ]
  logInfo $ "Cart purchase successful" :# ["cart_id" .= cartId]
  pure response

main :: IO ()
main = do
  app <- appInit
  waiApp <- toWaiAppPlain app
  let port = 3000
  run port waiApp
